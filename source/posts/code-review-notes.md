---
title: Code review заметки
created: 2022-10-08 16:30:06
tags: [code review, dart, flutter]
---

# Code review заметки

Этот пост является первым постом в серии "Code review заметки". В этих постах
мы будем говорить о код ревью и рассматривать примеры ошибок, которые совершаются
в реальной жизни и на реальных проектах. Будем пытаться улучшать свои и коллег навыки,
учиться на ошибках (опять-таки своих и чужих), а так же разбираться почему
тот или иной код заслужил внимание. Как этот код поправить и избежать подобных ошибок
в будущем. Человечество так устроено, что единственное, что у него получается блестяще
так это совершать ошибки. И на самом деле не так-то и много способов избежать подобных
ошибок. <more/>

## Зачем об этом писать?

Может показаться, что смысла в подобных статьях не очень много. И на это есть множество
разных причин. Начиная с вопроса зачем выносить сор из избы? Заканчивая тем, что пользы
от подобных статей немного, т.к. у всех свой разный опыт и соответственно грабли тоже
отличаются.
На мой взгляд подобные статьи полезны по многим причинам. Во-первых, далеко не в каждой
компании делается код-ревью. И уж тем более не так много компаний делают код-ревью
должным образом. Отсюда возникает ситуация, когда разработчик имеет опыт работы в
нескольких компаниях, работал над разного рода проектами, имеет солидное резюме, но
по факту умеет писать относительно хороший код. К сожалению такое происходит сплошь и
рядом. На это может быть десятки разных причин, начиная от нехватки времени,
соответствующих специалистов, заканчивая отсутствием соответствующей культуры
разработки. Таким образом должно быть очевидно, что потребность в подобных статьях
особенно среди начинающих разработчиков должна быть.
На второй момент так же легко дать ответ. Как бы это странно не было, но большинство
разработчиков (особенно начинающих) делают довольно похожие ошибки. Само собой имеется
ввиду общая структура ошибок/проблемного кода. Несмотря на то, что, вроде бы все думают
по разному по факту получается, что ошибки, как буд-то списывали. Как говорится
такова жизнь. И если один, два или три раза расписать довольно обширное объяснение
проблемы в комментариях к MR-у может быть не напряжено (опять-таки далеко не у всех аналогичные
взгляды), то описывать одно и тоже десятками раз может довольно быстро надоесть. Тут
опять-таки нужно помнить, что несмотря на то, что какие-то моменты разъяснялись,
обсуждались и правились, это ровным счетом никак не гарантируют, что разработчик
не совершить эту самую ошибку не далее чем завтра же в следующем MR-е. Таким образом
написание подобных постов должно помочь как твоим коллегам и тебе (не придется
описывать проблемные места довольно дотошно каждый раз, а можно указать ссылку на пост),
так и другим разработчикам, у которых тупо нет возможности быть хорошо проревьювенным.

![image](./step_on_a_rake.png)

Сегодня мы рассмотрим два примера из реальной жизни.

## Flutter и синтаксический сахар

Ближе к делу, рассмотрим следующий кусок кода:

```dart
    icon: Stack(
        clipBehavior: Clip.none,
        children: [
          Assets.icons.bell.svg(),
          if (notificationsCount > 0) ...{
            Positioned(
              top: -5,
              right: -5,
              child: Container(
                width: 10,
                height: 10,
                decoration: BoxDecoration(
                    color: selectedColor,
                    borderRadius: BorderRadius.circular(10)),
              ),
            )
          }
        ],
    ),
```

Прежде чем написать об основной проблеме этого кода, попробуйте найти ее сами.
Это довольно полезное упражнение. И так...

Это довольно обычный Flutter код разметки некоторого виджета. С подобным кодом
Flutter разработчики работают каждый божий день. На первый взгляд может показаться,
что никаких особых проблем с этим кодом нет. Код как код. Но если присмотреться, то
кое-что может показаться странным. Странно то, как именно добавляется индикатор наличия
нотификаций. Конкретно нас интересует следующий фрагмент кода:

```dart
if (notificationsCount > 0) ...{

}
```

Что же здесь происходит, и что хотел автор добиться этим кодом?
Все просто: если количество уведомлений больше нуля (т.е. если есть
хотя бы одно уведомление), то необходимо отобразить индикатор новых
уведомлений поверх иконки уведомлений. Я был довольно сильно удивлен увидев
подобный код. Само собой это далеко не самый ужасный код, который можно
увидеть, но все же было неожиданно.

Начнем с того, что в данном конкретном виде этот код работает. Несмотря на то,
что, в общем случае, так писать, однозначно, не стоит, попадание именно этого
куска кода в прод особо ничего не сломало бы. Но опять-таки, если рассматривать
более общий код, то будет понятно, что даже такой, в данном случае,
относительно безобидный код нельзя пропускать далее MR-а. Это как раз одна из
причин почему делать код-ревью нужно и делать это нужно на постоянной основе.
Если подобный код просочиться в основную кодовую базу, это, с большой
вероятностью приведет к тому, что другие разработчики могут начать писать
аналогичный код.

Для добавления виджета индикатора в дерево виджетов используется в этом
коде используется `...` [spread оператор](https://dart.dev/guides/language/language-tour#spread-operator)
и `{}` [set literal](https://dart.dev/guides/language/language-tour#sets).
Таким образом, если переписать этот код без синтаксического сахара (который, возможно частично и
скрывает проблему), то мы получим код следующего вида:

```dart
    List<Widget> children = [Assets.icons.bell.svg()];
    if (notificationsCount > 0) {
        children.addAll({
            Positioned(
              top: -5,
              right: -5,
              child: Container(
                width: 10,
                height: 10,
                decoration: BoxDecoration(
                    color: selectedColor,
                    borderRadius: BorderRadius.circular(10)),
              ),
            )
          });
    }
    icon: Stack(
        clipBehavior: Clip.none,
        children: children,
    ),

```

Таким образом spread оператор был заменен на явный вызов метода
`List.addAll`. И теперь код стал чуточку более явным и прямо линейным.
И если его еще несколько упростить, то мы получим следующий код:

```dart
    List<Widget> children = [Assets.icons.bell.svg()];
    if (notificationsCount > 0) {
        Set<Widget> indicator = {
            Positioned(
                top: -5,
                right: -5,
                child: Container(
                width: 10,
                height: 10,
                decoration: BoxDecoration(
                    color: selectedColor,
                    borderRadius: BorderRadius.circular(10)),
                ),
            )
        };
        children.addAll(indicator);
    }
    icon: Stack(
        clipBehavior: Clip.none,
        children: children,
    ),

```

Теперь стало еще более наглядно, что этот код делает. И в чем же действительно
проблема. Получается, что для добавления виджета индикатора в список
отображения этот код создает временное множество (`Set`), состоящее из одного элемента (виджета
индикатора) и используя тот факт, что метод `List.addAll` принимает любое перечисление `Iterable<T>`,
а множество (`Set`) является перечислением этот код работает плюс-минус как надо. Таким образом,
может показаться, что основная проблема этого кода в том, что создается временный, да еще и
относительно "тяжелый" объект множества.

## Как исправить код?

Разобравшись с корнем проблемы давайте разберемся как написать этот код лучше? На самом деле
ничего сложного нет:

```dart
    icon: Stack(
        clipBehavior: Clip.none,
        children: [
          Assets.icons.bell.svg(),
          if (notificationsCount > 0) 
            Positioned(
              top: -5,
              right: -5,
              child: Container(
                width: 10,
                height: 10,
                decoration: BoxDecoration(
                    color: selectedColor,
                    borderRadius: BorderRadius.circular(10)),
              ),
            )
        ],
    ),
```

Да, в данном конкретном примере все так просто. Мы не используем ни spread оператор `...`, ни
set literal `{}`. Такой код не создает временных объектов и работает максимально прозрачно, прост
в понимании и именно к такому коду и стоит стремиться. Если мы избавимся от синтаксического
сахара в этом примере, то код будет выглядеть примерно так:

```dart
    List<Widget> children = [Assets.icons.bell.svg()];
    if (notificationsCount > 0) { 
        children.add(
            Positioned(
              top: -5,
              right: -5,
              child: Container(
                width: 10,
                height: 10,
                decoration: BoxDecoration(
                    color: selectedColor,
                    borderRadius: BorderRadius.circular(10)),
              ),
            )
        );
    }
    icon: Stack(
        clipBehavior: Clip.none,
        children: children,
    ),
```

В этом коде все максимально прозрачно (хотя и несколько подробно) и вероятность сделать ошибку так
же минимальна.

## Акт второй

Как уже ранее было сказано, людям свойственно наступать на одни и те же грабли. И это нормально). Но
печально. Давайте рассмотрим фрагмент кода буквально одного из следующих MR-ов:

```dart
Row(
    children: [
    if (avatarImageName != null) ...{
          Text(
            context.ln.welcome,
          ),
          Text(
            '$avatarImageName!',
          ),
        } else ...{
          Text(context.ln.homeScreenTitle),
        }
    ],
),
```

И если предыдущий фрагмент кода с натяжкой (большой) можно было пропустить, то здесь уже все
несколько хуже. Давайте разбираться, что же с этим кодом не так, и чем же этот фрагмент кода,
с виду очень сильно похожий на предыдущий, гораздо хуже?

Очевидно, что все проблемы описывающие предыдущий фрагмент кода присущи и этому. И часть проблем
мы уже знаем как поправить:

```dart
Row(
    children: [
    if (avatarImageName != null) ...{
          Text(
            context.ln.welcome,
          ),
          Text(
            '$avatarImageName!',
          ),
        } else 
          Text(context.ln.homeScreenTitle),
    ],
),
```

Ветка `else` благополучно была отрефакторена аналогично предыдущему примеру. Но выполнить
аналогичный маневр с первой частью условия `if` увы не получится. Единственно, что мы можем (и
должны) сделать это заменить множество `Set` на список `List`. Теперь код будет выглядеть так:

```dart
Row(
    children: [
    if (avatarImageName != null) ...[
          Text(
            context.ln.welcome,
          ),
          Text(
            '$avatarImageName!',
          ),
        ] else 
          Text(context.ln.homeScreenTitle),
    ],
),
```

Теперь, несмотря на временное создание объекта (списка), код хотя бы стал корректным и делает,
именно то, что задумал автор. Так почему же код вида:

```dart
Row(
    children: [
    if (condigtion) ...{
            widgetA,
            widgetB,
        } 
    ],
),
```

некорректен? Вроде бы код не сильно отличается от предыдущего варианта. Который мы посчитали условно
(прямо как условно-съедобный)) корректным. Что же здесь не так? При запуске, вроде бы, все работает,
как и должно работать. Подумайте, прежде чем читать ответ. Это куда полезней.

Давайте обратимся к [документации](https://dart.dev/guides/language/language-tour#sets):

> A set in Dart is an ***unordered*** collection of unique items. Dart support for sets is provided by set literals and the Set type.

Теперь должно быть понятна основная проблема - порядок итерации по множеству не гарантирован! А это,
в свою очередь, значит, что виджеты в дереве отображения могут отобразиться в разном порядке.
Конечно же это совсем не то, что автор MR-а хотел реализовать. Собственно, как и всегда, дьявол кроется
в деталях, и вполне безобидный код (по крайней мере на первый взгляд) таит в себе довольно неприятные
сюрпризы. Думаю наконец-то стало понятно, почему так писать нельзя.

<details>
<summary>Спойлер</summary>
<div>

// TODO: расписать подробнее

</div>
</details>

## Откуда такой код мог взяться?

Стоит уделить минутку и подумать откуда такой код вообще мог появиться.

Конечно, на 100% выяснить откуда и как такой код появился на свет мало реально. Но некоторые 
возможные варианты, которые могли иметь место, можно: 

- маловероятно, что такой код был кем-то написан на предыдущем месте работы. Хотя и
полностью исключать такой вариант нельзя;
- можно предположить, что автор этого кода где-то когда-то видел код вида `...[ ]` или подобный,
но до конца не разобрался или не запомнил всех нюансов. Столкнулся с моментом когда необходимо
было добавить более одного виджета в список отображения, а код вида `if () {}` не работал как нужно,
и тогда на свет вполне мог появиться код вида `if () ...{}`, полагая, на интуитивном уровне, что
эти два куска кода идентичны, хотя это и не так.

### Выводы

Даже вполне безобидный код может делать совсем не то, что кажется. Подобный код, если бы не проходил
качественный процесс код-ревью вполне мог попасть в основную кодовую базу, и даже, довольно сильно
распространиться по ней. Довольно маловероятно, что подобную проблему малоопытный разработчик
смог бы сам найти. Про такое не пишут в книгах (по крайней мере явно), и разобраться без сторонней
помощи может быть не просто. 

Основной вывод который можно сделать из этого поучительного ревью - необходимо всегда понимать, что
твой код делает. Даже в таких мелочах. Код не должен работать каким-то магическим способом. Все 
должно кристально ясно и понятно, как автору, так и его коллегам. Учите мат. часть)

